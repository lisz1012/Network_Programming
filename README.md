# Network_Programming
BIO - NIO - AIO - Netty

NIO单线程模式会盯着ServerSocket上有没有Client连上来或者已有的Client有没有在往里写数据过来，发现一件事就处理一件事，Selector负责Client的连接跟连上来的Client的读写。连接还是建立在server上，selector负责读和写

NIO所有的通道都是和ByteBuffer（内存中的一个字节数组）连在一起的，好多字节积累下来一起读，BIO是一个字节一个字节来读的，速度比较慢。Netty的ByteBuffer里面有一个读指针一个写指针，封装要好得多
NIO需要定期轮询，看有没有人连接，AIO不需要，操作系统在监听，然后有人要连的时候通知selector大管家，线程不是越多越好，会增加线程切换的开销，要调试。这些IO模型底层都要通过操作系统处理

AIO主线程写好自己的代码，钩到操作系统的内核里头，什么时候一旦有人要连的时候就帮着执行Completed这段代码，一旦执行Completed，我又下一个钩子，钩到通道上，这通道要写的时候执行第二个CompletedHandler的completed（或failed）。不用轮询了，让操作系统帮忙。外层的CompletionHandler管的是连接，内层CompletionHandler管的是读写。netty跟AIO的写法差不多，但是对于ByteBuffer封装的更好

AIO和NIO在Linux底层都是用epoll实现的，epoll是Unix底层编程的一个模型，Linux上是同一种模型实现的。AIO其实还多了一层封装，因为epoll本身就是轮询模型。所以Netty对NIO进行了封装，封装的API更像AIO，AIO的好处在于其API更好用。Windows上的AIO并不是轮询模型，而确实是系统的事件模型，所以在Windows上用NIO，他的效率应该比Linux上要高。Netty只关心在Linux上的实现，因此Netty只封装了NIO，没管AIO。Netty可以用来处理REST API
